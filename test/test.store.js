// Generated by CoffeeScript 1.6.3
describe('Store', function() {
  var storageClass, storageName, _ref, _results;
  _ref = Backbone.storageAdapters;
  _results = [];
  for (storageName in _ref) {
    storageClass = _ref[storageName];
    _results.push((function(storageName, storageClass) {
      var _describe;
      _describe = storageClass === StickyStorage ? describe.skip : describe;
      return _describe("with " + storageName, function() {
        var model, otherModel, storage, store, storeClear, storeSetup, _ref1;
        storage = {}.storage;
        beforeEach(function(done) {
          storage = new storageClass;
          return storage.initialize().done(function() {
            return done();
          });
        });
        afterEach(function(done) {
          return storage.clear().done(function() {
            return done();
          });
        });
        it('takes a name and a storage adapter in its constructor', function() {
          var store;
          return store = new Backbone.Store('Store', storage);
        });
        it('initializes correctly', function(done) {
          var store;
          store = new Backbone.Store('Store', storage);
          expect(store.data).to.deep.eql({});
          return store.initialize().done(function() {
            expect(store.data.dirty).to.eql([]);
            expect(store.data.destroyed).to.eql([]);
            expect(store.data.local).to.eql([]);
            expect(store.data.records).to.eql([]);
            expect(store.data.recordsById).to.eql({});
            return done();
          });
        });
        _ref1 = {}, model = _ref1.model, otherModel = _ref1.otherModel, store = _ref1.store;
        storeSetup = function(done) {
          model = new Backbone.Model({
            id: 1,
            abc: 123
          });
          otherModel = new Backbone.Model({
            id: 2,
            xxx: 666
          });
          store = new Backbone.Store('Store', storage);
          return store.initialize().done(function() {
            return done();
          });
        };
        storeClear = function(done) {
          return store.clear().done(function() {
            return done();
          });
        };
        describe('when adding', function() {
          beforeEach(storeSetup);
          afterEach(storeClear);
          it('adds one model to the store', function(done) {
            return store.add(model).done(function(saved) {
              return storage.get('Store').done(function(storeData) {
                expect(storeData).to.deep.eql(store.data);
                expect(saved.attributes).to.deep.eql(model.attributes);
                expect(saved.attributes).to.deep.eql(storeData.recordsById[1]);
                expect(store.data).to.deep.eql({
                  records: [1],
                  recordsById: {
                    1: model.attributes
                  },
                  local: [],
                  dirty: [],
                  destroyed: []
                });
                return done();
              });
            });
          });
          it('adds many models to the store', function(done) {
            var models;
            models = [model, otherModel];
            return store.add(models).done(function(saved) {
              return storage.get('Store').done(function(storeData) {
                expect(storeData).to.deep.eql(store.data);
                expect(saved[0].attributes).to.deep.eql(model.attributes);
                expect(saved[0].attributes).to.deep.eql(storeData.recordsById[1]);
                expect(saved[1].attributes).to.deep.eql(otherModel.attributes);
                expect(saved[1].attributes).to.deep.eql(storeData.recordsById[2]);
                expect(store.data).to.deep.eql({
                  records: [1, 2],
                  recordsById: {
                    1: model.attributes,
                    2: otherModel.attributes
                  },
                  local: [],
                  dirty: [],
                  destroyed: []
                });
                return done();
              });
            });
          });
          it('adds the model creating a unique id using idAttribute', function(done) {
            model = new Backbone.Model({
              abc: 123
            });
            model.idAttribute = '_id';
            return store.add(model).done(function(saved) {
              return storage.get('Store').done(function(storeData) {
                var expectedAttr, recordsById;
                expectedAttr = {
                  abc: 123,
                  _id: model.id
                };
                expect(storeData).to.deep.eql(store.data);
                expect(saved.attributes).to.deep.eql(expectedAttr);
                expect(saved.attributes).to.deep.eql(storeData.recordsById[model.id]);
                expect(saved.id).to.equal(model.id);
                recordsById = {};
                recordsById[model.id] = model.attributes;
                expect(store.data).to.deep.eql({
                  records: [model.id],
                  recordsById: recordsById,
                  local: [model.id],
                  dirty: [],
                  destroyed: []
                });
                return done();
              });
            });
          });
          return it('throws an error if the model is already in the store', function(done) {
            return store.add(model).done(function(saved) {
              expect(function() {
                return store.add(model);
              }).to["throw"](/already in the store/);
              return done();
            });
          });
        });
        describe('when updating', function() {
          beforeEach(storeSetup);
          afterEach(storeClear);
          it('updates the model in the store', function(done) {
            return store.add(model).done(function() {
              model.set({
                abc: 666
              });
              return store.update(model).done(function(updated) {
                return storage.get('Store').done(function(storeData) {
                  expect(storeData).to.deep.eql(store.data);
                  expect(updated.attributes).to.deep.eql(model.attributes);
                  expect(updated.attributes).to.deep.eql(storeData.recordsById[1]);
                  expect(store.data).to.deep.eql({
                    records: [1],
                    recordsById: {
                      1: model.attributes
                    },
                    local: [],
                    dirty: [],
                    destroyed: []
                  });
                  return done();
                });
              });
            });
          });
          it('throws an error if the model does not have an id', function() {
            model = new Backbone.Model;
            return expect(function() {
              return store.update(model);
            }).to["throw"](/model does not have an id/);
          });
          return it('throws an error if the model is not in the store', function() {
            return expect(function() {
              return store.update(model);
            }).to["throw"](/is not in the store/);
          });
        });
        describe('when removing', function() {
          beforeEach(storeSetup);
          afterEach(storeClear);
          it('removes the model from the store', function(done) {
            return store.add(model).done(function() {
              return store.remove(model).done(function(removed) {
                return storage.get('Store').done(function(storeData) {
                  expect(storeData).to.deep.eql(store.data);
                  expect(removed.attributes).to.deep.eql(model.attributes);
                  expect(store.data).to.deep.eql({
                    records: [],
                    recordsById: {},
                    local: [],
                    dirty: [],
                    destroyed: []
                  });
                  return done();
                });
              });
            });
          });
          it('removes a local model from the store', function(done) {
            model = new Backbone.Model;
            return store.add(model).done(function() {
              return store.remove(model).done(function() {
                return storage.get('Store').done(function(storeData) {
                  expect(storeData).to.deep.eql(store.data);
                  expect(store.data).to.deep.eql({
                    records: [],
                    recordsById: {},
                    local: [],
                    dirty: [],
                    destroyed: []
                  });
                  return done();
                });
              });
            });
          });
          it('removes the model from the dirty list', function(done) {
            return store.add(model).done(function() {
              return store.isDirty(model, true).done(function() {
                return store.remove(model).done(function() {
                  return storage.get('Store').done(function(storeData) {
                    expect(storeData).to.deep.eql(store.data);
                    expect(store.data).to.deep.eql({
                      records: [],
                      recordsById: {},
                      local: [],
                      dirty: [],
                      destroyed: []
                    });
                    return done();
                  });
                });
              });
            });
          });
          return it('clears the store removing all saved data', function(done) {
            return store.add(model).done(function() {
              return store.isDirty(model, true).done(function() {
                return store.isDestroyed(otherModel, true).done(function() {
                  return store.clear().done(function() {
                    return storage.get('Store').done(function(storeData) {
                      expect(storeData).to.deep.eql({});
                      expect(store.data).to.deep.eql({});
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
        describe('when searching', function() {
          beforeEach(storeSetup);
          afterEach(storeClear);
          it('finds a model', function(done) {
            return store.add(model).done(function() {
              expect(store.find(1)).to.deep.eql(model.attributes);
              return done();
            });
          });
          it('finds all models', function(done) {
            return store.add(model).done(function() {
              return store.add(otherModel).done(function() {
                var models;
                models = [model.attributes, otherModel.attributes];
                expect(store.find()).to.deep.eql(models);
                return done();
              });
            });
          });
          it('finds all dirty models', function(done) {
            return store.add(model).done(function() {
              return store.isDirty(model, true).done(function() {
                expect(store.findDirty()).to.deep.eql([model.attributes]);
                return done();
              });
            });
          });
          it('finds all destroyed models', function(done) {
            return store.isDestroyed(model, true).done(function() {
              expect(store.findDestroyed()).to.deep.eql([model.id]);
              return done();
            });
          });
          return it('returns correct values when model is not found', function() {
            expect(store.find(1)).to.be.undefined;
            expect(store.findDirty(1)).to.be.undefined;
            return expect(store.findDestroyed(1)).to.be["false"];
          });
        });
        return describe('dirty / destroyed flags', function(done) {
          beforeEach(storeSetup);
          afterEach(storeClear);
          it('marks a model as dirty', function(done) {
            return store.add(model).done(function() {
              return store.isDirty(model, true).done(function(dirtyModel) {
                return storage.get('Store').done(function(storeData) {
                  expect(storeData).to.deep.eql(store.data);
                  expect(dirtyModel.attributes).to.deep.eql(model.attributes);
                  expect(store.data).to.deep.eql({
                    records: [1],
                    recordsById: {
                      1: model.attributes
                    },
                    local: [],
                    dirty: [1],
                    destroyed: []
                  });
                  return done();
                });
              });
            });
          });
          it('marks a model as destroyed', function(done) {
            return store.isDestroyed(model, true).done(function(destroyedModel) {
              return storage.get('Store').done(function(storeData) {
                expect(storeData).to.deep.eql(store.data);
                expect(destroyedModel.attributes).to.deep.eql(model.attributes);
                expect(store.data).to.deep.eql({
                  records: [],
                  recordsById: {},
                  local: [],
                  dirty: [],
                  destroyed: [1]
                });
                return done();
              });
            });
          });
          it('unmarks a model as dirty', function(done) {
            return store.add(model).done(function() {
              return store.isDirty(model, true).done(function() {
                return store.isDirty(model, false).done(function(dirtyModel) {
                  return storage.get('Store').done(function(storeData) {
                    expect(storeData).to.deep.eql(store.data);
                    expect(dirtyModel.attributes).to.deep.eql(model.attributes);
                    expect(store.data).to.deep.eql({
                      records: [1],
                      recordsById: {
                        1: model.attributes
                      },
                      local: [],
                      dirty: [],
                      destroyed: []
                    });
                    return done();
                  });
                });
              });
            });
          });
          it('unmarks a model as destroyed', function(done) {
            return store.isDestroyed(model, true).done(function() {
              return store.isDestroyed(model, false).done(function(dirtyModel) {
                return storage.get('Store').done(function(storeData) {
                  expect(storeData).to.deep.eql(store.data);
                  expect(dirtyModel.attributes).to.deep.eql(model.attributes);
                  expect(store.data).to.deep.eql({
                    records: [],
                    recordsById: {},
                    local: [],
                    dirty: [],
                    destroyed: []
                  });
                  return done();
                });
              });
            });
          });
          it('reports correctly if there are dirty models', function(done) {
            return store.add(model).done(function() {
              return store.isDirty(model, true).done(function() {
                expect(store.hasDirtyOrDestroyed).to.be.ok;
                return done();
              });
            });
          });
          it('reports correctly if there are destroyed models', function(done) {
            return store.isDestroyed(model, true).done(function() {
              expect(store.hasDirtyOrDestroyed).to.be.ok;
              return done();
            });
          });
          it('throws an error if the model is not in the store', function() {
            return expect(function() {
              return store.isDirty(model, true);
            }).to["throw"](/is not in the store/);
          });
          return it('throws an error if trying to mark a stored model as destroyed', function(done) {
            return store.add(model).done(function() {
              expect(function() {
                return store.isDestroyed(model, true);
              }).to["throw"](/is still in the store/);
              return done();
            });
          });
        });
      });
    })(storageName, storageClass));
  }
  return _results;
});
