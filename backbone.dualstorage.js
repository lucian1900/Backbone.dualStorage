// Generated by CoffeeScript 1.6.3
/*
Backbone dualStorage Adapter v1.1.0

A simple module to replace `Backbone.sync` with *localStorage*-based
persistence. Models are given GUIDS, and saved into a JSON object. Simple
as that.
*/


(function() {
  var S4, backboneSync, callbackTranslator, dualsync, getOnlineSyncFunc, isLocallyCached, isModelPersisted, localSyncFirst, localsync, modelUpdatedWithResponse, onlineSync, onlineSyncQueue, parseRemoteResponse, remoteSyncFirst, result;

  Backbone.Collection.prototype.syncDirty = function(callback) {
    var id, ids, model, store, storeName, url, _i, _len, _results;
    if (onlineSyncQueue.isSyncInProgress()) {
      return;
    }
    url = result(this, 'url');
    storeName = result(this, 'storeName');
    store = localStorage.getItem(("" + url + "_dirty") || localStorage.getItem("" + storeName + "_dirty"));
    ids = (store && store.split(',')) || [];
    _results = [];
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      id = ids[_i];
      model = id.length === 36 ? this.findWhere({
        id: id
      }) : this.get(id);
      _results.push(model != null ? model.save() : void 0);
    }
    return _results;
  };

  Backbone.Collection.prototype.syncDestroyed = function() {
    var id, ids, model, store, storeName, url, _i, _len, _results;
    if (onlineSyncQueue.isSyncInProgress()) {
      return;
    }
    url = result(this, 'url');
    storeName = result(this, 'storeName');
    store = localStorage.getItem(("" + url + "_destroyed") || (store = localStorage.getItem("" + storeName + "_destroyed")));
    ids = (store && store.split(',')) || [];
    _results = [];
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      id = ids[_i];
      model = new this.model({
        id: id
      });
      model.collection = this;
      _results.push(model.destroy());
    }
    return _results;
  };

  Backbone.Collection.prototype.syncDirtyAndDestroyed = function() {
    this.syncDirty();
    return this.syncDestroyed();
  };

  S4 = function() {
    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
  };

  window.Store = (function() {
    Store.prototype.sep = '';

    function Store(name) {
      this.name = name;
      this.records = this.recordsOn(this.name);
    }

    Store.prototype.generateId = function() {
      return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();
    };

    Store.prototype.save = function() {
      return localStorage.setItem(this.name, this.records.join(','));
    };

    Store.prototype.recordsOn = function(key) {
      var store;
      store = localStorage.getItem(key);
      return (store && store.split(',')) || [];
    };

    Store.prototype.dirty = function(model) {
      var dirtyRecords;
      dirtyRecords = this.recordsOn(this.name + '_dirty');
      if (!_.include(dirtyRecords, model.id.toString())) {
        dirtyRecords.push(model.id);
        localStorage.setItem(this.name + '_dirty', dirtyRecords.join(','));
      }
      return model;
    };

    Store.prototype.clean = function(model, from) {
      var dirtyRecords, store;
      store = "" + this.name + "_" + from;
      dirtyRecords = this.recordsOn(store);
      if (_.include(dirtyRecords, model.id.toString())) {
        localStorage.setItem(store, _.without(dirtyRecords, model.id.toString()).join(','));
      }
      return model;
    };

    Store.prototype.destroyed = function(model) {
      var destroyedRecords;
      destroyedRecords = this.recordsOn(this.name + '_destroyed');
      if (!_.include(destroyedRecords, model.id.toString())) {
        destroyedRecords.push(model.id);
        localStorage.setItem(this.name + '_destroyed', destroyedRecords.join(','));
      }
      return model;
    };

    Store.prototype.create = function(model) {
      if (!_.isObject(model)) {
        return model;
      }
      if (!model.id) {
        model.id = this.generateId();
        model.set(model.idAttribute, model.id);
      }
      localStorage.setItem(this.name + this.sep + model.id, JSON.stringify(model));
      this.records.push(model.id.toString());
      this.save();
      return model;
    };

    Store.prototype.update = function(model) {
      localStorage.setItem(this.name + this.sep + model.id, JSON.stringify(model));
      if (!_.include(this.records, model.id.toString())) {
        this.records.push(model.id.toString());
      }
      this.save();
      return model;
    };

    Store.prototype.clear = function() {
      var id, _i, _len, _ref;
      _ref = this.records;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        localStorage.removeItem(this.name + this.sep + id);
      }
      this.records = [];
      return this.save();
    };

    Store.prototype.hasDirtyOrDestroyed = function() {
      return !_.isEmpty(localStorage.getItem(this.name + '_dirty')) || !_.isEmpty(localStorage.getItem(this.name + '_destroyed'));
    };

    Store.prototype.find = function(model) {
      var modelAsJson;
      modelAsJson = localStorage.getItem(this.name + this.sep + model.id);
      if (modelAsJson === null) {
        return null;
      }
      return JSON.parse(modelAsJson);
    };

    Store.prototype.findAll = function() {
      var id, _i, _len, _ref, _results;
      _ref = this.records;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        _results.push(JSON.parse(localStorage.getItem(this.name + this.sep + id)));
      }
      return _results;
    };

    Store.prototype.destroy = function(model) {
      localStorage.removeItem(this.name + this.sep + model.id);
      this.records = _.reject(this.records, function(record_id) {
        return record_id === model.id.toString();
      });
      this.save();
      return model;
    };

    return Store;

  })();

  callbackTranslator = {
    needsTranslation: Backbone.VERSION === '0.9.10',
    forBackboneCaller: function(callback) {
      if (this.needsTranslation) {
        return function(model, resp, options) {
          return callback.call(null, resp);
        };
      } else {
        return callback;
      }
    },
    forDualstorageCaller: function(callback, model, options) {
      if (this.needsTranslation) {
        return function(resp) {
          return callback.call(null, model, resp, options);
        };
      } else {
        return callback;
      }
    }
  };

  onlineSyncQueue = (function() {
    var currentTask, isReadTaskInStore, queue, removeReadTasksFromStore, reset, sync, tasks;
    tasks = [];
    currentTask = null;
    reset = function() {
      tasks = [];
      return currentTask = null;
    };
    sync = function() {
      currentTask = tasks.shift();
      if (currentTask) {
        currentTask.promise = currentTask.task();
        return currentTask.promise.done(function() {
          return sync();
        }).fail(function() {
          return reset();
        });
      } else {
        return reset();
      }
    };
    isReadTaskInStore = function(task, storeName) {
      return (task.method === 'read') && (task.storeName === storeName);
    };
    removeReadTasksFromStore = function(storeName) {
      tasks = _.reject(tasks, (function(task) {
        return isReadTaskInStore(task, storeName);
      }));
      if ((currentTask != null) && isReadTaskInStore(currentTask, storeName)) {
        return currentTask.promise.abort();
      }
    };
    return queue = {
      isSyncInProgress: function() {
        return currentTask != null;
      },
      length: function() {
        return tasks.length;
      },
      push: function(task, method, storeName) {
        removeReadTasksFromStore(storeName);
        tasks.push({
          task: task,
          method: method,
          storeName: storeName
        });
        if (!this.isSyncInProgress()) {
          return sync();
        }
      }
    };
  })();

  getOnlineSyncFunc = function(method, model, successCallback) {
    return function() {
      return onlineSync(method, model, {
        success: successCallback
      });
    };
  };

  localsync = function(method, model, options) {
    var isValidModel, preExisting, response, store;
    console.log("CALL: localsync", method, options);
    isValidModel = (method === 'clear') || (method === 'hasDirtyOrDestroyed');
    isValidModel || (isValidModel = model instanceof Backbone.Model);
    isValidModel || (isValidModel = model instanceof Backbone.Collection);
    if (!isValidModel) {
      throw new Error('model parameter is required to be a backbone model or collection.');
    }
    store = new Store(options.storeName);
    response = (function() {
      switch (method) {
        case 'read':
          if (model.id) {
            return store.find(model);
          } else {
            return store.findAll();
          }
          break;
        case 'hasDirtyOrDestroyed':
          return store.hasDirtyOrDestroyed();
        case 'clear':
          return store.clear();
        case 'create':
          if (!(options.add && !options.merge && (preExisting = store.find(model)))) {
            model = store.create(model);
            if (options.dirty) {
              store.dirty(model);
            }
            return model;
          } else {
            return preExisting;
          }
          break;
        case 'update':
          store.update(model);
          if (options.dirty) {
            return store.dirty(model);
          } else {
            return store.clean(model, 'dirty');
          }
          break;
        case 'delete':
          store.destroy(model);
          if (options.dirty) {
            return store.destroyed(model);
          } else {
            if (model.id.toString().length === 36) {
              return store.clean(model, 'dirty');
            } else {
              return store.clean(model, 'destroyed');
            }
          }
      }
    })();
    if (response != null ? response.attributes : void 0) {
      response = response.attributes;
    }
    if (!options.ignoreCallbacks) {
      if (response) {
        options.success(response);
      } else {
        options.error('Record not found');
      }
    }
    return response;
  };

  result = function(object, property) {
    var value;
    if (!object) {
      return null;
    }
    value = object[property];
    if (_.isFunction(value)) {
      return value.call(object);
    } else {
      return value;
    }
  };

  parseRemoteResponse = function(object, response) {
    if (!(object && object.parseBeforeLocalSave)) {
      return response;
    }
    if (_.isFunction(object.parseBeforeLocalSave)) {
      return object.parseBeforeLocalSave(response);
    }
  };

  isModelPersisted = function(model) {
    return !(_.isString(model.id) && model.id.length === 36);
  };

  isLocallyCached = function(storeName) {
    return localStorage.getItem(storeName);
  };

  modelUpdatedWithResponse = function(model, response) {
    var modelClone;
    modelClone = new Backbone.Model;
    modelClone.idAttribute = model.idAttribute;
    modelClone.urlRoot = model.collection.url;
    modelClone.set(model.attributes);
    modelClone.set(modelClone.parse(response));
    return modelClone;
  };

  backboneSync = Backbone.sync;

  onlineSync = function(method, model, options) {
    console.log("CALL: onlineSync", method, model.id);
    options.success = callbackTranslator.forBackboneCaller(options.success);
    options.error = callbackTranslator.forBackboneCaller(options.error);
    return backboneSync(method, model, options);
  };

  dualsync = function(method, model, options) {
    var local;
    console.log("CALL: dualsync", method, model.id);
    options.storeName = result(model.collection, 'storeName') || result(model, 'storeName') || result(model.collection, 'url') || result(model, 'urlRoot') || result(model, 'url');
    options.success = callbackTranslator.forDualstorageCaller(options.success, model, options);
    options.error = callbackTranslator.forDualstorageCaller(options.error, model, options);
    if (result(model, 'remote') || result(model.collection, 'remote')) {
      return onlineSync(method, model, options);
    }
    if (result(model, 'localFirst') || result(model.collection, 'localFirst')) {
      return localSyncFirst(method, model, options);
    }
    local = result(model, 'local') || result(model.collection, 'local');
    options.dirty = options.remote === false && !local;
    if (options.remote === false || local) {
      return localsync(method, model, options);
    }
    return remoteSyncFirst(method, model, options);
  };

  localSyncFirst = function(method, model, options) {
    var deleteLocal, localsyncOptions, onlineSyncSuccess, storeServerResponse, storeServerResponseAndUpdateModel, url;
    console.log("CALL: localSyncFirst", method, model.id);
    switch (method) {
      case 'read':
        if (localsync('hasDirtyOrDestroyed', model, {
          ignoreCallbacks: true,
          storeName: options.storeName
        })) {
          return localsync(method, model, options);
        } else {
          storeServerResponse = function(resp) {
            var backboneModelMethod, collection, idAttribute, localsyncOptions, modelsToRemove, setOpts, updatedResp, _i, _len, _ref;
            localsyncOptions = _.clone(options);
            localsyncOptions.ignoreCallbacks = true;
            resp = parseRemoteResponse(model, resp);
            if (_.isArray(resp)) {
              collection = model;
              idAttribute = collection.model.prototype.idAttribute;
              backboneModelMethod = localsyncOptions.reset ? 'reset' : 'set';
              modelsToRemove = [];
              _.each(collection.models, function(element, index, list) {
                if (isModelPersisted(element)) {
                  if (!_.findWhere(resp, {
                    id: element.get('id')
                  })) {
                    return modelsToRemove.push(element);
                  }
                }
              });
              _.each(modelsToRemove, function(element) {
                localsync('delete', element, {
                  storeName: options.storeName,
                  ignoreCallbacks: true
                });
                return collection.remove(element);
              });
              setOpts = _.clone(options);
              setOpts.remove = false;
              collection[backboneModelMethod](resp, setOpts);
              localsync('clear', collection, localsyncOptions);
              _ref = collection.models;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                model = _ref[_i];
                localsync('create', model, localsyncOptions);
              }
            } else {
              model[backboneModelMethod](resp, options);
              localsync('clear', model, localsyncOptions);
              localsync('create', model, localsyncOptions);
            }
            updatedResp = JSON.parse(JSON.stringify(collection.models));
            model.trigger('sync', model, updatedResp, options);
            return updatedResp;
          };
          onlineSyncSuccess = function(resp, status, xhr) {
            var updatedResp;
            updatedResp = storeServerResponse(resp, status, xhr);
            return options.success(updatedResp, status, xhr);
          };
          if (!isLocallyCached(options.storeName)) {
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, onlineSyncSuccess), method, options.storeName);
          }
          localsyncOptions = _.clone(options);
          localsyncOptions.success = function(resp, status, xhr) {
            options.success(resp, status, xhr);
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, storeServerResponse), method, options.storeName);
          };
          localsyncOptions.error = function(resp, status, xhr) {
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, onlineSyncSuccess), method, options.storeName);
          };
          return localsync(method, model, localsyncOptions);
        }
        break;
      case 'create':
        storeServerResponse = function(resp, status, xhr) {
          localsyncOptions = _.clone(options);
          localsyncOptions.ignoreCallbacks = true;
          localsync('delete', model, localsyncOptions);
          resp = parseRemoteResponse(model, resp);
          options.success(resp);
          return localsync(method, model, localsyncOptions);
        };
        onlineSyncSuccess = function(resp, status, xhr) {
          storeServerResponse(resp, status, xhr);
          return options.success(resp, status, xhr);
        };
        localsyncOptions = _.clone(options);
        localsyncOptions.dirty = true;
        localsyncOptions.success = function(resp, status, xhr) {
          var modelToSend;
          options.success(resp, status, xhr);
          modelToSend = modelUpdatedWithResponse(model, resp);
          modelToSend.set(model.idAttribute, null, {
            silent: true
          });
          return onlineSyncQueue.push(getOnlineSyncFunc(method, modelToSend, storeServerResponse), method, options.storeName);
        };
        localsyncOptions.error = function(resp, status, xhr) {
          return onlineSyncQueue.push(getOnlineSyncFunc(method, model, onlineSyncSuccess), method, options.storeName);
        };
        return localsync(method, model, localsyncOptions);
      case 'update':
        storeServerResponseAndUpdateModel = function(resp) {
          localsyncOptions = _.clone(options);
          localsyncOptions.ignoreCallbacks = true;
          if (deleteLocal) {
            localsync('delete', model, localsyncOptions);
          }
          resp = parseRemoteResponse(model, resp);
          options.success(resp);
          return localsync(method, model, localsyncOptions);
        };
        onlineSyncSuccess = function(resp, status, xhr) {
          storeServerResponseAndUpdateModel(resp, status, xhr);
          return options.success(resp, status, xhr);
        };
        localsyncOptions = _.clone(options);
        localsyncOptions.dirty = true;
        deleteLocal = false;
        if (isModelPersisted(model)) {
          localsyncOptions.success = function(resp, status, xhr) {
            options.success(resp, status, xhr);
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, storeServerResponseAndUpdateModel), method, options.storeName);
          };
          localsyncOptions.error = function(resp, status, xhr) {
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, onlineSyncSuccess), method, options.storeName);
          };
        } else {
          localsyncOptions.success = function(resp, status, xhr) {
            var modelToSend;
            options.success(resp, status, xhr);
            deleteLocal = true;
            modelToSend = modelUpdatedWithResponse(model, resp);
            modelToSend.set(model.idAttribute, null, {
              silent: true
            });
            return onlineSyncQueue.push(getOnlineSyncFunc('create', modelToSend, storeServerResponseAndUpdateModel), method, options.storeName);
          };
          localsyncOptions.error = function(resp, status, xhr) {
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, onlineSyncSuccess), method, options.storeName);
          };
        }
        return localsync(method, model, localsyncOptions);
      case 'delete':
        url = model.url();
        storeServerResponse = function(resp) {
          localsyncOptions = _.clone(options);
          localsyncOptions.ignoreCallbacks = true;
          localsyncOptions.dirty = false;
          return localsync('delete', model, localsyncOptions);
        };
        onlineSyncSuccess = function(resp, status, xhr) {
          storeServerResponse(resp, status, xhr);
          return options.success(resp, status, xhr);
        };
        localsyncOptions = _.clone(options);
        localsyncOptions.dirty = true;
        model.url = url;
        if (isModelPersisted(model)) {
          localsyncOptions.success = function(resp, status, xhr) {
            options.success(resp, status, xhr);
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, storeServerResponse), method, options.storeName);
          };
          localsyncOptions.error = function(resp, status, xhr) {
            return onlineSyncQueue.push(getOnlineSyncFunc(method, model, onlineSyncSuccess), method, options.storeName);
          };
        } else {
          localsyncOptions.success = function(resp, status, xhr) {
            return options.success(resp, status, xhr);
          };
          localsyncOptions.error = function(resp, status, xhr) {
            var message;
            message = "Backbone.dualStorage: localSyncFirst DELETE failed.";
            console.error(message);
            return options.error({
              message: message
            });
          };
        }
        return _.defer(localsync, method, model, localsyncOptions);
    }
  };

  remoteSyncFirst = function(method, model, options) {
    var error, success, temporaryId;
    console.log("CALL: remoteSyncFirst", method, model.id);
    options.ignoreCallbacks = true;
    success = options.success;
    error = options.error;
    switch (method) {
      case 'read':
        if (localsync('hasDirtyOrDestroyed', model, options)) {
          return success(localsync(method, model, options));
        } else {
          options.success = function(resp, status, xhr) {
            var collection, idAttribute, modelAttributes, responseModel, _i, _len;
            resp = parseRemoteResponse(model, resp);
            if (!options.add) {
              localsync('clear', model, options);
            }
            if (_.isArray(resp)) {
              collection = model;
              idAttribute = collection.model.prototype.idAttribute;
              for (_i = 0, _len = resp.length; _i < _len; _i++) {
                modelAttributes = resp[_i];
                model = collection.get(modelAttributes[idAttribute]);
                if (model) {
                  responseModel = modelUpdatedWithResponse(model, modelAttributes);
                } else {
                  responseModel = new collection.model(modelAttributes);
                }
                localsync('create', responseModel, options);
              }
            } else {
              responseModel = modelUpdatedWithResponse(model, resp);
              localsync('create', responseModel, options);
            }
            return success(resp, status, xhr);
          };
          options.error = function(resp) {
            return success(localsync(method, model, options));
          };
          return onlineSync(method, model, options);
        }
        break;
      case 'create':
        options.success = function(resp, status, xhr) {
          var updatedModel;
          updatedModel = modelUpdatedWithResponse(model, resp);
          localsync(method, updatedModel, options);
          return success(resp, status, xhr);
        };
        options.error = function(resp) {
          options.dirty = true;
          return success(localsync(method, model, options));
        };
        return onlineSync(method, model, options);
      case 'update':
        if (_.isString(model.id) && model.id.length === 36) {
          temporaryId = model.id;
          options.success = function(resp, status, xhr) {
            var updatedModel;
            updatedModel = modelUpdatedWithResponse(model, resp);
            model.set(model.idAttribute, temporaryId, {
              silent: true
            });
            localsync('delete', model, options);
            localsync('create', updatedModel, options);
            return success(resp, status, xhr);
          };
          options.error = function(resp) {
            options.dirty = true;
            model.set(model.idAttribute, temporaryId, {
              silent: true
            });
            return success(localsync(method, model, options));
          };
          model.set(model.idAttribute, null, {
            silent: true
          });
          return onlineSync('create', model, options);
        } else {
          options.success = function(resp, status, xhr) {
            var updatedModel;
            updatedModel = modelUpdatedWithResponse(model, resp);
            localsync(method, updatedModel, options);
            return success(resp, status, xhr);
          };
          options.error = function(resp) {
            options.dirty = true;
            return success(localsync(method, model, options));
          };
          return onlineSync(method, model, options);
        }
        break;
      case 'delete':
        if (_.isString(model.id) && model.id.length === 36) {
          return localsync(method, model, options);
        } else {
          options.success = function(resp, status, xhr) {
            localsync(method, model, options);
            return success(resp, status, xhr);
          };
          options.error = function(resp) {
            options.dirty = true;
            return success(localsync(method, model, options));
          };
          return onlineSync(method, model, options);
        }
    }
  };

  Backbone.sync = dualsync;

}).call(this);
