// Generated by CoffeeScript 1.6.3
var S4, dualSync, localSync, onlineSync, updateModelWithResponse,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Backbone.storageAdapters = {};

Backbone.storageAdapters.LocalStorageAdapter = (function() {
  function LocalStorageAdapter(name) {
    this.name = name || 'Backbone.dualStorage.LocalStorage';
    this.store = localStorage;
  }

  LocalStorageAdapter.prototype.initialize = function() {
    return $.Deferred().resolve();
  };

  LocalStorageAdapter.prototype.set = function(key, value) {
    this.store.setItem(key, JSON.stringify(value));
    return $.Deferred().resolve(value);
  };

  LocalStorageAdapter.prototype.get = function(key) {
    return $.Deferred().resolve(JSON.parse(this.store.getItem(key)));
  };

  LocalStorageAdapter.prototype.remove = function(key) {
    this.store.removeItem(key);
    return $.Deferred().resolve();
  };

  LocalStorageAdapter.prototype.clear = function() {
    this.store.clear();
    return $.Deferred().resolve();
  };

  return LocalStorageAdapter;

})();

Backbone.storageAdapters.LawnchairStorageAdapter = (function() {
  function LawnchairStorageAdapter(name) {
    this.name = name || 'Backbone.dualStorage.Lawnchair';
  }

  LawnchairStorageAdapter.prototype.initialize = function() {
    var promise;
    promise = $.Deferred();
    this.store = new Lawnchair({
      name: this.name,
      adapter: ['indexed-db']
    }, function() {
      return promise.resolve();
    });
    return promise;
  };

  LawnchairStorageAdapter.prototype.set = function(key, value) {
    var promise;
    promise = $.Deferred();
    this.store.save({
      key: key,
      value: value
    }, function(data) {
      return promise.resolve(data.value);
    });
    return promise;
  };

  LawnchairStorageAdapter.prototype.get = function(key) {
    var promise;
    promise = $.Deferred();
    this.store.get(key, function(data) {
      return promise.resolve(data != null ? data.value : void 0);
    });
    return promise;
  };

  LawnchairStorageAdapter.prototype.remove = function(key) {
    var promise;
    promise = $.Deferred();
    this.store.remove(key, function() {
      return promise.resolve();
    });
    return promise;
  };

  LawnchairStorageAdapter.prototype.clear = function() {
    var promise;
    promise = $.Deferred();
    this.store.nuke(function() {
      return promise.resolve();
    });
    return promise;
  };

  return LawnchairStorageAdapter;

})();

Backbone.storageAdapters.StickyStorageAdapter = (function() {
  function StickyStorageAdapter(name) {
    this.name = name || 'Backbone.dualStorage.Sticky';
  }

  StickyStorageAdapter.prototype.initialize = function() {
    var promise;
    promise = $.Deferred();
    this.store = new StickyStore({
      name: this.name,
      adapters: ['indexedDB'],
      ready: function() {
        return promise.resolve();
      }
    });
    return promise;
  };

  StickyStorageAdapter.prototype.set = function(key, value) {
    var promise;
    promise = $.Deferred();
    this.store.set({
      key: key,
      value: value
    }, function(data) {
      return promise.resolve(data.value);
    });
    return promise;
  };

  StickyStorageAdapter.prototype.get = function(key) {
    var promise;
    promise = $.Deferred();
    this.store.get(key, function(data) {
      return promise.resolve(data != null ? data.value : void 0);
    });
    return promise;
  };

  StickyStorageAdapter.prototype.remove = function(key) {
    var promise;
    promise = $.Deferred();
    this.store.remove(key, function() {
      return promise.resolve();
    });
    return promise;
  };

  StickyStorageAdapter.prototype.clear = function() {
    var promise;
    promise = $.Deferred();
    this.store.removeAll(function() {
      return promise.resolve();
    });
    return promise;
  };

  return StickyStorageAdapter;

})();

Backbone.Store = (function() {
  function Store(name, storage) {
    this.name = name;
    this.storage = storage;
    this.data = {};
  }

  Store.prototype.generateId = function() {
    return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();
  };

  Store.prototype.initialize = function() {
    var _this = this;
    return this.storage.get(this.name).then(function(savedData) {
      _this.data.records = (savedData != null ? savedData.records : void 0) || [];
      _this.data.dirty = (savedData != null ? savedData.dirty : void 0) || [];
      _this.data.destroyed = (savedData != null ? savedData.destroyed : void 0) || [];
      _this.data.local = (savedData != null ? savedData.local : void 0) || [];
      return _this.data.recordsById = (savedData != null ? savedData.recordsById : void 0) || {};
    });
  };

  Store.prototype.save = function() {
    return this.storage.set(this.name, this.data);
  };

  Store.prototype.toggleModel = function(target, model, status) {
    var _ref, _ref1;
    if (status && (_ref = model.id, __indexOf.call(this.data[target], _ref) < 0)) {
      this.data[target].push(model.id);
    } else if (!status && (_ref1 = model.id, __indexOf.call(this.data[target], _ref1) >= 0)) {
      this.data[target] = _.without(this.data[target], model.id);
    }
    return this.save().then(function() {
      return model;
    });
  };

  Store.prototype.isDirty = function(model, status) {
    var _ref, _ref1;
    if (_ref = model.id, __indexOf.call(this.data.records, _ref) < 0) {
      throw new Error("model with id " + model.id + " is not in the store.");
    }
    if (_ref1 = model.id, __indexOf.call(this.data.destroyed, _ref1) >= 0) {
      throw new Error("can't mark model with id " + model.id + " as dirty because it is marked as destroyed.");
    }
    return this.toggleModel('dirty', model, status);
  };

  Store.prototype.isDestroyed = function(model, status) {
    var _ref, _ref1;
    if (_ref = model.id, __indexOf.call(this.data.records, _ref) >= 0) {
      throw new Error("can't mark model with id " + model.id + " as destroyed because it is still in the store.");
    }
    if (_ref1 = model.id, __indexOf.call(this.data.dirty, _ref1) >= 0) {
      throw new Error("can't mark model with id " + model.id + " as destroyed because it is marked as dirty.");
    }
    return this.toggleModel('destroyed', model, status);
  };

  Store.prototype.add = function(models) {
    var model, _i, _len, _ref;
    if (!_.isArray(models)) {
      models = [models];
    }
    for (_i = 0, _len = models.length; _i < _len; _i++) {
      model = models[_i];
      if (_ref = model.id, __indexOf.call(this.data.records, _ref) >= 0) {
        throw new Error("model with id " + model.id + " is already in the store.");
      }
      if (!model.id) {
        model.id = this.generateId();
        model.set(model.idAttribute, model.id);
        this.data.local.push(model.id);
      }
      this.data.records.push(model.id);
      this.data.recordsById[model.id] = model.toJSON();
    }
    return this.save().then(function() {
      if (models.length === 1) {
        return models[0];
      } else {
        return models;
      }
    });
  };

  Store.prototype.update = function(model) {
    var _ref;
    if (!model.id) {
      throw new Error("model does not have an id.");
    }
    if (_ref = model.id, __indexOf.call(this.data.records, _ref) < 0) {
      throw new Error("model with id " + model.id + " is not in the store, try adding instead of updating.");
    }
    this.data.recordsById[model.id] = model.toJSON();
    return this.save().then(function() {
      return model;
    });
  };

  Store.prototype.remove = function(model) {
    delete this.data.recordsById[model.id];
    this.data.dirty = _.without(this.data.dirty, model.id);
    this.data.local = _.without(this.data.local, model.id);
    this.data.records = _.without(this.data.records, model.id);
    return this.save().then(function() {
      return model;
    });
  };

  Store.prototype.clear = function() {
    this.data = {};
    return this.save();
  };

  Store.prototype.find = function(id) {
    var model, _ref, _results;
    if (id) {
      return this.data.recordsById[id];
    } else {
      _ref = this.data.recordsById;
      _results = [];
      for (id in _ref) {
        model = _ref[id];
        _results.push(model);
      }
      return _results;
    }
  };

  Store.prototype.findDirty = function(id) {
    var _i, _len, _ref, _results;
    if (id) {
      if (__indexOf.call(this.data.dirty, id) >= 0) {
        return this.data.recordsById[id];
      }
    } else {
      _ref = this.data.dirty;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        _results.push(this.data.recordsById[id]);
      }
      return _results;
    }
  };

  Store.prototype.findDestroyed = function(id) {
    if (id) {
      return __indexOf.call(this.data.destroyed, id) >= 0;
    } else {
      return this.data.destroyed;
    }
  };

  Store.prototype.hasDirtyOrDestroyed = function() {
    return !_.isEmpty(this.data.dirty) || !_.isEmpty(this.data.destroyed);
  };

  return Store;

})();

S4 = function() {
  return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
};

localSync = function(method, model, options) {
  var isValidModel, returnAsync, store;
  isValidModel = method === 'clear' || method === 'hasDirtyOrDestroyed';
  isValidModel || (isValidModel = model instanceof Backbone.Model);
  isValidModel || (isValidModel = model instanceof Backbone.Collection);
  if (!isValidModel) {
    throw new Error('model parameter is required to be a Backbone model or collection.');
  }
  if (!options.storeName) {
    throw new Error('storeName parameter is required.');
  }
  if (!options.storage) {
    throw new Error('storage parameter is required.');
  }
  returnAsync = function() {
    return $.Deferred().resolve;
  };
  store = new Backbone.Store(options.storeName, options.storage);
  return store.initialize().then(function() {
    var promise;
    promise = (function() {
      switch (method) {
        case 'read':
          return returnAsync(store.find(model != null ? model.id : void 0));
        case 'create':
          return store.add(model).then(function(model) {
            return store.isDirty(model, options.offline);
          });
        case 'update':
          return store.update(model).then(function(model) {
            return store.isDirty(model, options.offline);
          });
        case 'remove':
          return store.remove(model).then(function(model) {
            return store.isDestroyed(model, options.offline);
          });
        case 'clear':
          return store.clear();
        case 'hasDirtyOrDestroyed':
          return returnAsync(store.hasDirtyOrDestroyed());
      }
    })();
    if (options.useCallbacks) {
      return promise.done(function(response) {
        return options.success((response != null ? response.attributes : void 0) || response);
      });
    }
  });
};

updateModelWithResponse = function(model, response) {
  var modelClone;
  modelClone = new Backbone.Model;
  modelClone.idAttribute = model.idAttribute;
  modelClone.set(model.attributes);
  modelClone.set(modelClone.parse(response));
  return modelClone;
};

onlineSync = Backbone.sync;

dualSync = function(method, model, options) {
  var error, onlyLocal, success, temporaryId;
  options.storeName = _.result(model.collection, 'storeName') || _.result(model, 'storeName') || _.result(model.collection, 'url') || _.result(model, 'urlRoot') || _.result(model, 'url');
  if (_.result(model, 'onlyRemote') || _.result(model.collection, 'onlyRemote')) {
    return onlineSync(method, model, options);
  }
  onlyLocal = _.result(model, 'onlyLocal') || _.result(model.collection, 'onlyLocal');
  options.offline = !onlyLocal && options.remote === false;
  if (onlyLocal || options.remote === false) {
    return localSync(method, model, options).done(function(response) {
      return options != null ? options.success(model, response, options) : void 0;
    });
  }
  success = options.success;
  error = options.error;
  switch (method) {
    case 'read':
      return localSync('hasDirtyOrDestroyed', model, options).then(function(hasDirtyOrDestroyed) {
        var returnModel;
        if (hasDirtyOrDestroyed) {
          return localSync('read', model, options).done(function(response) {
            return options != null ? options.success(model, response, options) : void 0;
          });
        } else {
          returnModel = model;
          options.success = function(model, response, options) {
            var collection, idAttribute, modelAttributes, models, promise, _i, _len;
            models = [];
            if (_.isArray(response)) {
              collection = model;
              idAttribute = collection.model.prototype.idAttribute;
              for (_i = 0, _len = response.length; _i < _len; _i++) {
                modelAttributes = response[_i];
                model = collection.get(modelAttributes[idAttribute]);
                model && (model = updateModelWithResponse(model, modelAttributes));
                if (!model) {
                  model = new collection.model(modelAttributes);
                }
                models.push(model);
              }
            } else {
              models = [updateModelWithResponse(model, response)];
            }
            if (!options.add) {
              promise = localSync('clear', model, options);
            } else {
              promise = $.Deferred().resolve();
            }
            return promise.done = function() {
              var promises;
              promises = (function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = models.length; _j < _len1; _j++) {
                  model = models[_j];
                  _results.push(localSync('create', model, options));
                }
                return _results;
              })();
              return $.when.apply($, promises).then(function() {
                return typeof success === "function" ? success(returnModel, response, options) : void 0;
              });
            };
          };
          options.error = function(model, response, options) {
            return localSync('read', model, options).then(function(response) {
              return typeof success === "function" ? success(model, response, options) : void 0;
            });
          };
          return onlineSync('read', model, options);
        }
      });
    case 'create':
      options.success = function(model, response, options) {
        var updatedModel;
        updatedModel = updateModelWithResponse(model, response);
        return localSync('create', updatedModel, options).then(function(savedModel) {
          return typeof success === "function" ? success(model, savedModel.attributes, options) : void 0;
        });
      };
      options.error = function(model, response, options) {
        options.offline = true;
        return localSync('create', model, options).then(function(savedModel) {
          return typeof success === "function" ? success(model, savedModel.attributes, options) : void 0;
        });
      };
      return onlineSync('create', model, options);
    case 'update':
      if ((model != null ? model.id.length : void 0) === 36) {
        temporaryId = model.id;
        options.success = function(model, response, options) {
          var updatedModel;
          updatedModel = updateModelWithResponse(model, response);
          model.set(model.idAttribute, temporaryId, {
            silent: true
          });
          return localSync('remove', model, options).then(function() {
            return localSync('create', updatedModel, options).then(function(savedModel) {
              return typeof success === "function" ? success(savedModel, savedModel.attributes, options) : void 0;
            });
          });
        };
        options.error = function(model, response, options) {
          options.offline = true;
          model.set(model.idAttribute, temporaryId, {
            silent: true
          });
          return localSync('update', model, options).then(function(savedModel) {
            return typeof success === "function" ? success(savedModel, savedModel.attributes, options) : void 0;
          });
        };
        model.set(model.idAttribute, null, {
          silent: true
        });
        return onlineSync('create', model, options);
      } else {
        options.success = function(model, response, options) {
          var updatedModel;
          updatedModel = updateModelWithResponse(model, response);
          return localSync('update', updatedModel, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        options.error = function(model, response, options) {
          options.offline = true;
          return localSync('update', model, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        return onlineSync('update', model, options);
      }
      break;
    case 'remove':
      if ((model != null ? model.id.length : void 0) === 36) {
        return localSync('remove', model, options);
      } else {
        options.success = function(model, response, options) {
          return localSync('remove', model, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        options.error = function(model, response, options) {
          options.offline = true;
          return localSync('remove', model, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        return onlineSync('remove', model, options);
      }
  }
};

Backbone.onlineSync = onlineSync;

Backbone.dualSync = dualSync;
