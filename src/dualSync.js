// Generated by CoffeeScript 1.6.3
var dualSync, onlineSync, updateModelWithResponse;

updateModelWithResponse = function(model, response) {
  var modelClone;
  modelClone = new Backbone.Model;
  modelClone.idAttribute = model.idAttribute;
  modelClone.set(model.attributes);
  modelClone.set(modelClone.parse(response));
  return modelClone;
};

onlineSync = Backbone.sync;

dualSync = function(method, model, options) {
  var error, onlyLocal, success, temporaryId;
  options.storeName = _.result(model.collection, 'storeName') || _.result(model, 'storeName') || _.result(model.collection, 'url') || _.result(model, 'urlRoot') || _.result(model, 'url');
  if (_.result(model, 'onlyRemote') || _.result(model.collection, 'onlyRemote')) {
    return onlineSync(method, model, options);
  }
  onlyLocal = _.result(model, 'onlyLocal') || _.result(model.collection, 'onlyLocal');
  options.offline = !onlyLocal && options.remote === false;
  if (onlyLocal || options.remote === false) {
    return localSync(method, model, options).done(function(response) {
      return options != null ? options.success(model, response, options) : void 0;
    });
  }
  success = options.success;
  error = options.error;
  switch (method) {
    case 'read':
      return localSync('hasDirtyOrDestroyed', model, options).then(function(hasDirtyOrDestroyed) {
        var returnModel;
        if (hasDirtyOrDestroyed) {
          return localSync('read', model, options).done(function(response) {
            return options != null ? options.success(model, response, options) : void 0;
          });
        } else {
          returnModel = model;
          options.success = function(model, response, options) {
            var collection, idAttribute, modelAttributes, models, promise, _i, _len;
            models = [];
            if (_.isArray(response)) {
              collection = model;
              idAttribute = collection.model.prototype.idAttribute;
              for (_i = 0, _len = response.length; _i < _len; _i++) {
                modelAttributes = response[_i];
                model = collection.get(modelAttributes[idAttribute]);
                model && (model = updateModelWithResponse(model, modelAttributes));
                if (!model) {
                  model = new collection.model(modelAttributes);
                }
                models.push(model);
              }
            } else {
              models = [updateModelWithResponse(model, response)];
            }
            if (!options.add) {
              promise = localSync('clear', model, options);
            } else {
              promise = $.Deferred().resolve();
            }
            return promise.done = function() {
              var promises;
              promises = (function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = models.length; _j < _len1; _j++) {
                  model = models[_j];
                  _results.push(localSync('create', model, options));
                }
                return _results;
              })();
              return $.when.apply($, promises).then(function() {
                return typeof success === "function" ? success(returnModel, response, options) : void 0;
              });
            };
          };
          options.error = function(model, response, options) {
            return localSync('read', model, options).then(function(response) {
              return typeof success === "function" ? success(model, response, options) : void 0;
            });
          };
          return onlineSync('read', model, options);
        }
      });
    case 'create':
      options.success = function(model, response, options) {
        var updatedModel;
        updatedModel = updateModelWithResponse(model, response);
        return localSync('create', updatedModel, options).then(function(savedModel) {
          return typeof success === "function" ? success(model, savedModel.attributes, options) : void 0;
        });
      };
      options.error = function(model, response, options) {
        options.offline = true;
        return localSync('create', model, options).then(function(savedModel) {
          return typeof success === "function" ? success(model, savedModel.attributes, options) : void 0;
        });
      };
      return onlineSync('create', model, options);
    case 'update':
      if ((model != null ? model.id.length : void 0) === 36) {
        temporaryId = model.id;
        options.success = function(model, response, options) {
          var updatedModel;
          updatedModel = updateModelWithResponse(model, response);
          model.set(model.idAttribute, temporaryId, {
            silent: true
          });
          return localSync('remove', model, options).then(function() {
            return localSync('create', updatedModel, options).then(function(savedModel) {
              return typeof success === "function" ? success(savedModel, savedModel.attributes, options) : void 0;
            });
          });
        };
        options.error = function(model, response, options) {
          options.offline = true;
          model.set(model.idAttribute, temporaryId, {
            silent: true
          });
          return localSync('update', model, options).then(function(savedModel) {
            return typeof success === "function" ? success(savedModel, savedModel.attributes, options) : void 0;
          });
        };
        model.set(model.idAttribute, null, {
          silent: true
        });
        return onlineSync('create', model, options);
      } else {
        options.success = function(model, response, options) {
          var updatedModel;
          updatedModel = updateModelWithResponse(model, response);
          return localSync('update', updatedModel, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        options.error = function(model, response, options) {
          options.offline = true;
          return localSync('update', model, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        return onlineSync('update', model, options);
      }
      break;
    case 'remove':
      if ((model != null ? model.id.length : void 0) === 36) {
        return localSync('remove', model, options);
      } else {
        options.success = function(model, response, options) {
          return localSync('remove', model, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        options.error = function(model, response, options) {
          options.offline = true;
          return localSync('remove', model, options).then(function() {
            return typeof success === "function" ? success(model, response, options) : void 0;
          });
        };
        return onlineSync('remove', model, options);
      }
  }
};

Backbone.onlineSync = onlineSync;

Backbone.dualSync = dualSync;
